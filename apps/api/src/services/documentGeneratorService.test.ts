/**
 * Document Generator Service Tests
 */

import { documentGeneratorService } from './documentGeneratorService';

// Mock storage service
jest.mock('./storageService', () => ({
  storageService: {
    isConfigured: jest.fn().mockReturnValue(false),
    getPresignedDownloadUrl: jest.fn(),
  },
}));

describe('DocumentGeneratorService', () => {
  const baseOptions = {
    userId: 'user-123',
    organizationId: 'org-123',
  };

  describe('generatePDF', () => {
    it('should generate a PDF buffer', async () => {
      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content: '# Meeting Summary\n\n- Action item 1\n- Action item 2',
        format: 'pdf',
        title: 'Test Meeting Summary',
      });

      expect(result.fileName).toMatch(/Test_Meeting_Summary_\d+\.pdf/);
      expect(result.fileSize).toBeGreaterThan(0);
      expect(result.mimeType).toBe('application/pdf');
      expect(result.downloadUrl).toMatch(/^data:application\/pdf;base64,/);
      expect(result.expiresAt).toBeInstanceOf(Date);
    });

    it('should handle markdown formatting in PDF', async () => {
      const content = `# Heading 1
## Heading 2
### Heading 3

- Bullet point
* Another bullet

1. Numbered item
2. Another numbered item

Regular paragraph text.`;

      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content,
        format: 'pdf',
        title: 'Formatted Document',
      });

      expect(result.fileSize).toBeGreaterThan(0);
      expect(result.mimeType).toBe('application/pdf');
    });
  });

  describe('generateDOCX', () => {
    it('should generate a DOCX buffer', async () => {
      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content: '# Meeting Notes\n\nSome important notes here.',
        format: 'docx',
        title: 'Meeting Notes',
      });

      expect(result.fileName).toMatch(/Meeting_Notes_\d+\.docx/);
      expect(result.fileSize).toBeGreaterThan(0);
      expect(result.mimeType).toBe('application/vnd.openxmlformats-officedocument.wordprocessingml.document');
      expect(result.downloadUrl).toMatch(/^data:application\/vnd\.openxmlformats-officedocument\.wordprocessingml\.document;base64,/);
    });

    it('should handle headings in DOCX', async () => {
      const content = `# Main Title
## Section 1
Some content here.

## Section 2
More content.`;

      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content,
        format: 'docx',
        title: 'Structured Document',
      });

      expect(result.fileSize).toBeGreaterThan(0);
    });
  });

  describe('generateMarkdown', () => {
    it('should generate a Markdown buffer', async () => {
      const content = 'This is the content';
      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content,
        format: 'md',
        title: 'My Document',
      });

      expect(result.fileName).toMatch(/My_Document_\d+\.md/);
      expect(result.fileSize).toBeGreaterThan(0);
      expect(result.mimeType).toBe('text/markdown');

      // Decode and verify content
      const base64Data = result.downloadUrl.replace('data:text/markdown;base64,', '');
      const decodedContent = Buffer.from(base64Data, 'base64').toString('utf-8');
      expect(decodedContent).toContain('# My Document');
      expect(decodedContent).toContain('This is the content');
      expect(decodedContent).toContain('Generated by zigznote');
    });
  });

  describe('generateCSV', () => {
    it('should generate CSV from action items', async () => {
      const content = `- Update documentation (John) - Due: Jan 15
- Review PR #123 (Sarah)
- Schedule team meeting (Mike) Due: Jan 20`;

      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content,
        format: 'csv',
        title: 'Action Items',
      });

      expect(result.fileName).toMatch(/Action_Items_\d+\.csv/);
      expect(result.mimeType).toBe('text/csv');

      // Decode and verify CSV structure
      const base64Data = result.downloadUrl.replace('data:text/csv;base64,', '');
      const decodedContent = Buffer.from(base64Data, 'base64').toString('utf-8');
      expect(decodedContent).toContain('Item,Assignee,Due Date,Status');
      expect(decodedContent).toContain('John');
      expect(decodedContent).toContain('Sarah');
    });

    it('should generate simple CSV from list', async () => {
      const content = `- First item
- Second item
- Third item`;

      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content,
        format: 'csv',
        title: 'Simple List',
      });

      const base64Data = result.downloadUrl.replace('data:text/csv;base64,', '');
      const decodedContent = Buffer.from(base64Data, 'base64').toString('utf-8');
      expect(decodedContent).toContain('Item');
      expect(decodedContent).toContain('First item');
    });
  });

  describe('title sanitization', () => {
    it('should sanitize title for filename', async () => {
      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content: 'Test content',
        format: 'md',
        title: 'Meeting: Sales/Marketing Review (Q1 2024)',
      });

      expect(result.fileName).toMatch(/Meeting_SalesMarketing_Review_Q1_2024_\d+\.md/);
    });

    it('should truncate long titles', async () => {
      const longTitle = 'A'.repeat(100);
      const result = await documentGeneratorService.generate({
        ...baseOptions,
        content: 'Test content',
        format: 'md',
        title: longTitle,
      });

      // Title should be truncated to 50 chars max
      expect(result.fileName.split('_')[0]!.length).toBeLessThanOrEqual(50);
    });
  });

  describe('error handling', () => {
    it('should throw error for unsupported format', async () => {
      await expect(
        documentGeneratorService.generate({
          ...baseOptions,
          content: 'Test',
          format: 'xyz' as 'pdf',
          title: 'Test',
        })
      ).rejects.toThrow('Unsupported format: xyz');
    });
  });
});
